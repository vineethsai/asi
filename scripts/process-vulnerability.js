#!/usr/bin/env node

/**
 * Vulnerability Submission Processor
 * 
 * This script processes markdown vulnerability submissions and converts them
 * to JSON entries for the vulnerability database.
 * 
 * Usage:
 *   node scripts/process-vulnerability.js <markdown-file>
 *   node scripts/process-vulnerability.js submissions/AVD-2024-001-example.md
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Helper function to parse markdown content
function parseMarkdownSubmission(content) {
  const lines = content.split('\n');
  const vulnerability = {
    id: '',
    title: '',
    description: '',
    severity: 'medium',
    cvss_score: 0.0,
    cve_id: null,
    disclosure_date: '',
    discovered_by: '',
    affected_systems: [],
    vulnerability_type: '',
    attack_vector: '',
    impact: {
      confidentiality: false,
      integrity: false,
      availability: false
    },
    technical_details: {
      attack_method: '',
      exploitation_complexity: 'medium',
      user_interaction: 'required',
      scope: 'unchanged'
    },
    threat_mapping: [],
    aisvs_mapping: [],
    mitigation_mapping: [],
    proof_of_concept: {
      available: false,
      description: ''
    },
    remediation: {
      vendor_response: '',
      workarounds: [],
      patch_status: 'not_patched'
    },
    references: [],
    tags: [],
    status: 'disclosed',
    last_updated: new Date().toISOString().split('T')[0]
  };

  let currentSection = '';
  let currentSubsection = '';
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Skip empty lines
    if (!line) continue;
    
    // Parse headers
    if (line.startsWith('##')) {
      currentSection = line.replace(/^#+\s*/, '').toLowerCase();
      currentSubsection = '';
      continue;
    }
    
    if (line.startsWith('###')) {
      currentSubsection = line.replace(/^#+\s*/, '').toLowerCase();
      continue;
    }
    
    // Parse basic information
    if (currentSection === 'basic information') {
      if (line.includes('**Title**:')) {
        vulnerability.title = line.split('**Title**:')[1].trim().replace(/^\[|\]$/g, '');
      } else if (line.includes('**Severity**:')) {
        vulnerability.severity = line.split('**Severity**:')[1].trim().replace(/^\[|\]$/g, '');
      } else if (line.includes('**CVSS Score**:')) {
        vulnerability.cvss_score = parseFloat(line.split('**CVSS Score**:')[1].trim().replace(/^\[|\]$/g, '')) || 0.0;
      } else if (line.includes('**CVE ID**:')) {
        const cveId = line.split('**CVE ID**:')[1].trim().replace(/^\[|\]$/g, '');
        vulnerability.cve_id = cveId && cveId !== 'If assigned, otherwise leave blank' ? cveId : null;
      } else if (line.includes('**Disclosure Date**:')) {
        vulnerability.disclosure_date = line.split('**Disclosure Date**:')[1].trim().replace(/^\[|\]$/g, '');
      } else if (line.includes('**Discovered By**:')) {
        vulnerability.discovered_by = line.split('**Discovered By**:')[1].trim().replace(/^\[|\]$/g, '');
      }
    }
    
    // Parse affected systems
    if (currentSection === 'affected systems') {
      if (line.startsWith('-') && !line.includes('[List affected')) {
        vulnerability.affected_systems.push(line.substring(1).trim());
      }
    }
    
    // Parse vulnerability details
    if (currentSection === 'vulnerability details') {
      if (line.includes('**Type**:')) {
        vulnerability.vulnerability_type = line.split('**Type**:')[1].trim().replace(/^\[|\]$/g, '');
      } else if (line.includes('**Attack Vector**:')) {
        vulnerability.attack_vector = line.split('**Attack Vector**:')[1].trim().replace(/^\[|\]$/g, '');
      } else if (line.includes('**Description**:')) {
        vulnerability.description = line.split('**Description**:')[1].trim().replace(/^\[|\]$/g, '');
      }
      
      // Technical details subsection
      if (currentSubsection === 'technical details') {
        if (line.includes('**Attack Method**:')) {
          vulnerability.technical_details.attack_method = line.split('**Attack Method**:')[1].trim().replace(/^\[|\]$/g, '');
        } else if (line.includes('**Exploitation Complexity**:')) {
          vulnerability.technical_details.exploitation_complexity = line.split('**Exploitation Complexity**:')[1].trim().replace(/^\[|\]$/g, '');
        } else if (line.includes('**User Interaction**:')) {
          vulnerability.technical_details.user_interaction = line.split('**User Interaction**:')[1].trim().replace(/^\[|\]$/g, '');
        } else if (line.includes('**Scope**:')) {
          vulnerability.technical_details.scope = line.split('**Scope**:')[1].trim().replace(/^\[|\]$/g, '');
        }
      }
      
      // Impact assessment subsection
      if (currentSubsection === 'impact assessment') {
        if (line.includes('**Confidentiality**:')) {
          vulnerability.impact.confidentiality = line.includes('true');
        } else if (line.includes('**Integrity**:')) {
          vulnerability.impact.integrity = line.includes('true');
        } else if (line.includes('**Availability**:')) {
          vulnerability.impact.availability = line.includes('true');
        }
      }
    }
    
    // Parse threat mappings
    if (currentSection === 'threat model mapping') {
      if (line.includes('- [x]') && line.includes('t')) {
        const match = line.match(/t(\d+)/);
        if (match) {
          vulnerability.threat_mapping.push(`t${match[1]}`);
        }
      }
    }
    
    // Parse AISVS mappings
    if (currentSection === 'aisvs controls mapping') {
      if (line.includes('- [x]') && line.includes('v')) {
        const match = line.match(/v(\d+)\.x\.x/);
        if (match) {
          // This is a simplified mapping - in practice, you'd want more specific control IDs
          vulnerability.aisvs_mapping.push(`v${match[1]}.1.1`);
        }
      }
    }
    
    // Parse mitigation mappings
    if (currentSection === 'mitigation mapping') {
      if (line.includes('- [x]') && line.includes('m')) {
        const match = line.match(/m(\d+)/);
        if (match) {
          vulnerability.mitigation_mapping.push(`m${match[1]}`);
        }
      }
    }
    
    // Parse proof of concept
    if (currentSection === 'proof of concept') {
      if (line.includes('**Available**:')) {
        vulnerability.proof_of_concept.available = line.includes('true');
      } else if (line.includes('**Description**:')) {
        vulnerability.proof_of_concept.description = line.split('**Description**:')[1].trim().replace(/^\[|\]$/g, '');
      }
    }
    
    // Parse remediation
    if (currentSection === 'remediation') {
      if (currentSubsection === 'vendor response') {
        if (!line.startsWith('#') && !line.includes('**')) {
          vulnerability.remediation.vendor_response += line + ' ';
        }
      } else if (currentSubsection === 'workarounds') {
        if (line.startsWith('-') && !line.includes('[List temporary')) {
          vulnerability.remediation.workarounds.push(line.substring(1).trim());
        }
      } else if (currentSubsection === 'patch status') {
        if (!line.startsWith('#') && !line.includes('**')) {
          vulnerability.remediation.patch_status = line.trim().replace(/^\[|\]$/g, '');
        }
      }
    }
    
    // Parse references
    if (currentSection === 'references') {
      if (line.includes('**Title**:') && line.includes('**URL**:')) {
        const titleMatch = line.match(/\*\*Title\*\*:\s*([^*]+)/);
        const urlMatch = line.match(/\*\*URL\*\*:\s*([^*]+)/);
        const typeMatch = line.match(/\*\*Type\*\*:\s*([^*]+)/);
        
        if (titleMatch && urlMatch) {
          vulnerability.references.push({
            title: titleMatch[1].trim(),
            url: urlMatch[1].trim(),
            type: typeMatch ? typeMatch[1].trim() : 'blog_post'
          });
        }
      }
    }
    
    // Parse tags
    if (currentSection === 'tags') {
      if (!line.startsWith('#') && !line.includes('[Comma-separated')) {
        vulnerability.tags = line.split(',').map(tag => tag.trim()).filter(tag => tag);
      }
    }
  }
  
  // Clean up vendor response
  vulnerability.remediation.vendor_response = vulnerability.remediation.vendor_response.trim();
  
  return vulnerability;
}

// Generate next available ID
function generateNextId() {
  const vulnerabilityDbPath = path.join(__dirname, '../src/data/vulnerabilities.json');
  
  if (!fs.existsSync(vulnerabilityDbPath)) {
    return 'AVD-2024-001';
  }
  
  const vulnerabilities = JSON.parse(fs.readFileSync(vulnerabilityDbPath, 'utf8'));
  const currentYear = new Date().getFullYear();
  
  // Find highest number for current year
  let maxNum = 0;
  vulnerabilities.forEach(vuln => {
    const match = vuln.id.match(/AVD-(\d{4})-(\d{3})/);
    if (match && parseInt(match[1]) === currentYear) {
      maxNum = Math.max(maxNum, parseInt(match[2]));
    }
  });
  
  const nextNum = (maxNum + 1).toString().padStart(3, '0');
  return `AVD-${currentYear}-${nextNum}`;
}

// Main processing function
function processVulnerabilitySubmission(markdownFile) {
  if (!fs.existsSync(markdownFile)) {
    console.error(`Error: File ${markdownFile} not found`);
    process.exit(1);
  }
  
  console.log(`Processing vulnerability submission: ${markdownFile}`);
  
  const content = fs.readFileSync(markdownFile, 'utf8');
  const vulnerability = parseMarkdownSubmission(content);
  
  // Generate ID if not provided
  if (!vulnerability.id) {
    vulnerability.id = generateNextId();
  }
  
  console.log(`Generated/Assigned ID: ${vulnerability.id}`);
  
  // Validate required fields
  const requiredFields = ['title', 'description', 'severity', 'disclosure_date', 'discovered_by'];
  const missingFields = requiredFields.filter(field => !vulnerability[field]);
  
  if (missingFields.length > 0) {
    console.error(`Error: Missing required fields: ${missingFields.join(', ')}`);
    process.exit(1);
  }
  
  // Load existing database
  const vulnerabilityDbPath = path.join(__dirname, '../src/data/vulnerabilities.json');
  let vulnerabilities = [];
  
  if (fs.existsSync(vulnerabilityDbPath)) {
    vulnerabilities = JSON.parse(fs.readFileSync(vulnerabilityDbPath, 'utf8'));
  }
  
  // Check for duplicates
  const existingVuln = vulnerabilities.find(v => v.id === vulnerability.id);
  if (existingVuln) {
    console.log(`Updating existing vulnerability: ${vulnerability.id}`);
    const index = vulnerabilities.findIndex(v => v.id === vulnerability.id);
    vulnerabilities[index] = vulnerability;
  } else {
    console.log(`Adding new vulnerability: ${vulnerability.id}`);
    vulnerabilities.push(vulnerability);
  }
  
  // Sort by ID (newest first)
  vulnerabilities.sort((a, b) => b.id.localeCompare(a.id));
  
  // Write back to database
  fs.writeFileSync(vulnerabilityDbPath, JSON.stringify(vulnerabilities, null, 2));
  
  console.log('âœ… Vulnerability successfully processed and added to database');
  console.log(`ðŸ“Š Total vulnerabilities in database: ${vulnerabilities.length}`);
  
  // Output summary
  console.log('\nðŸ“‹ Summary:');
  console.log(`   ID: ${vulnerability.id}`);
  console.log(`   Title: ${vulnerability.title}`);
  console.log(`   Severity: ${vulnerability.severity}`);
  console.log(`   CVSS: ${vulnerability.cvss_score}`);
  console.log(`   Threat Mappings: ${vulnerability.threat_mapping.length}`);
  console.log(`   AISVS Mappings: ${vulnerability.aisvs_mapping.length}`);
  console.log(`   Mitigation Mappings: ${vulnerability.mitigation_mapping.length}`);
}

// CLI interface
if (process.argv[1] && process.argv[1].endsWith('process-vulnerability.js')) {
  const markdownFile = process.argv[2];
  
  if (!markdownFile) {
    console.log('Usage: node scripts/process-vulnerability.js <markdown-file>');
    console.log('');
    console.log('Example:');
    console.log('  node scripts/process-vulnerability.js submissions/AVD-2024-001-example.md');
    process.exit(1);
  }
  
  processVulnerabilitySubmission(markdownFile);
}

export { processVulnerabilitySubmission, parseMarkdownSubmission, generateNextId }; 