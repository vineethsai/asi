// Browser-compatible frontmatter parser
function parseFrontmatter(content: string) {
  const lines = content.split('\n');
  if (lines[0].trim() !== '---') {
    return { data: {}, content };
  }

  let endIndex = -1;
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].trim() === '---') {
      endIndex = i;
      break;
    }
  }

  if (endIndex === -1) {
    return { data: {}, content };
  }

  const frontmatterLines = lines.slice(1, endIndex);
  const markdownContent = lines.slice(endIndex + 1).join('\n');

  // Parse YAML-like frontmatter
  const data: any = {};
  const stack: any[] = [data];
  let currentObj = data;
  let currentKey = '';
  let indent = 0;

  for (let i = 0; i < frontmatterLines.length; i++) {
    const line = frontmatterLines[i];
    const trimmedLine = line.trim();
    
    if (!trimmedLine || trimmedLine.startsWith('#')) continue;

    // Calculate indentation
    const lineIndent = line.length - line.trimStart().length;

    // Handle array items
    if (trimmedLine.startsWith('- ')) {
      const item = trimmedLine.substring(2).trim();
      let parsedItem: any = item;

      // Handle nested objects in arrays
      if (item.includes(':')) {
        const colonIndex = item.indexOf(':');
        const key = item.substring(0, colonIndex).trim();
        const value = item.substring(colonIndex + 1).trim();
        parsedItem = { [key]: parseValue(value) };
      } else {
        parsedItem = parseValue(item);
      }

      if (Array.isArray(currentObj[currentKey])) {
        currentObj[currentKey].push(parsedItem);
      } else {
        currentObj[currentKey] = [parsedItem];
      }
      continue;
    }

    // Handle key-value pairs
    if (trimmedLine.includes(':')) {
      const colonIndex = trimmedLine.indexOf(':');
      const key = trimmedLine.substring(0, colonIndex).trim();
      const value = trimmedLine.substring(colonIndex + 1).trim();

      // Adjust object context based on indentation
      while (stack.length > 1 && lineIndent <= indent) {
        stack.pop();
        currentObj = stack[stack.length - 1];
        indent -= 2;
      }

      if (value === '') {
        // This is likely the start of a nested object or array
        currentKey = key;
        
        // Look ahead to see if next line is an array or object
        const nextLine = i + 1 < frontmatterLines.length ? frontmatterLines[i + 1] : '';
        const nextTrimmed = nextLine.trim();
        
        if (nextTrimmed.startsWith('- ')) {
          currentObj[key] = [];
        } else {
          currentObj[key] = {};
          stack.push(currentObj[key]);
          currentObj = currentObj[key];
          indent = lineIndent;
        }
      } else {
        // Simple key-value pair
        currentObj[key] = parseValue(value);
        currentKey = key;
      }
    }
  }

  return { data, content: markdownContent };
}

// Helper function to parse values
function parseValue(value: string): any {
  const trimmed = value.trim();
  
  // Remove quotes
  if ((trimmed.startsWith('"') && trimmed.endsWith('"')) || 
      (trimmed.startsWith("'") && trimmed.endsWith("'"))) {
    return trimmed.slice(1, -1);
  }
  
  // Parse booleans
  if (trimmed === 'true') return true;
  if (trimmed === 'false') return false;
  if (trimmed === 'null') return null;
  
  // Parse numbers
  if (!isNaN(Number(trimmed)) && trimmed !== '') {
    return Number(trimmed);
  }
  
  return trimmed;
}

// Define the vulnerability interface
export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: "critical" | "high" | "medium" | "low";
  cvss_score: number;
  cve_id?: string;
  disclosure_date: string;
  discovered_by: string;
  affected_systems: string[];
  vulnerability_type: string;
  attack_vector: string;
  impact: {
    confidentiality: boolean;
    integrity: boolean;
    availability: boolean;
  };
  technical_details: {
    attack_method: string;
    exploitation_complexity: "low" | "medium" | "high";
    user_interaction: "required" | "none";
    scope: "unchanged" | "changed";
  };
  threat_mapping: string[];
  mitigation_mapping: string[];
  proof_of_concept: {
    available: boolean;
    description: string;
  };
  remediation: {
    vendor_response: string;
    workarounds: string[];
    patch_status: string;
  };
  references: Array<{
    title: string;
    url: string;
    type: string;
  }>;
  tags: string[];
  status: string;
  last_updated: string;
  // Additional fields for markdown content
  content: string;
  slug: string;
}

// Use Vite's import.meta.glob to dynamically import all markdown files
const vulnerabilityModules = import.meta.glob('../data/vulnerabilities/*.md', { 
  query: '?raw',
  import: 'default',
  eager: true 
});

// Parse and load all vulnerabilities
export const loadVulnerabilities = (): Vulnerability[] => {
  const vulnerabilities: Vulnerability[] = [];

  for (const [path, content] of Object.entries(vulnerabilityModules)) {
    try {
      // Skip README.md file
      if (path.includes('README.md')) {
        continue;
      }
      
      // Parse the markdown with frontmatter
      const { data, content: markdownContent } = parseFrontmatter(content as string);
      
      // Extract slug from filename
      const slug = path.split('/').pop()?.replace('.md', '') || '';
      
      // Skip if no valid ID (basic validation)
      if (!data.id || !data.title) {
        console.warn(`Skipping invalid vulnerability file ${path}: missing id or title`);
        continue;
      }
      
      // Create vulnerability object
      const vulnerability: Vulnerability = {
        ...data,
        content: markdownContent,
        slug,
      } as Vulnerability;

      vulnerabilities.push(vulnerability);
    } catch (error) {
      console.error(`Error parsing vulnerability file ${path}:`, error);
    }
  }

  // Sort by disclosure date (newest first)
  return vulnerabilities.sort((a, b) => 
    new Date(b.disclosure_date).getTime() - new Date(a.disclosure_date).getTime()
  );
};

// Export a singleton instance
export const vulnerabilities = loadVulnerabilities();

// Helper function to get a vulnerability by ID
export const getVulnerabilityById = (id: string): Vulnerability | undefined => {
  return vulnerabilities.find(vuln => vuln.id === id);
};

// Helper function to get vulnerabilities by severity
export const getVulnerabilitiesBySeverity = (severity: string): Vulnerability[] => {
  return vulnerabilities.filter(vuln => vuln.severity === severity);
};

// Helper function to search vulnerabilities
export const searchVulnerabilities = (query: string): Vulnerability[] => {
  const lowercaseQuery = query.toLowerCase();
  return vulnerabilities.filter(vuln => 
    vuln.title.toLowerCase().includes(lowercaseQuery) ||
    vuln.description.toLowerCase().includes(lowercaseQuery) ||
    vuln.tags.some(tag => tag.toLowerCase().includes(lowercaseQuery)) ||
    vuln.affected_systems.some(system => system.toLowerCase().includes(lowercaseQuery)) ||
    vuln.discovered_by.toLowerCase().includes(lowercaseQuery) ||
    vuln.vulnerability_type.toLowerCase().includes(lowercaseQuery) ||
    vuln.content.toLowerCase().includes(lowercaseQuery)
  );
}; 